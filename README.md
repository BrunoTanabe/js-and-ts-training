<!-- markdownlint-disable -->

# CAPACITAÇÃO JAVASCRIPT & TYPESCRIPT

---

<details>
    <summary>Sumário</summary>
    <ol>
        <li>
            <a href="#1-extensões-para-vscode">Extensões para VsCode</a>
        </li>
        <li>
            <a href="#2-overview-java-script">Overview Java Script</a>
        </li>
        <li>
            <a href="#3-primeiro-hello-world">Primeiro Hello World</a>
        </li>
        <li>
            <a href="#4-lógica-de-programação-em-js">Lógica de Programação em JS</a>
        </li>
        <ol>
            <li>
                <a href="#41-princípios-de-programação">Princípios de programação</a>
            </li>
            <ol>
                <li>
                    <a href="#411-o-que-é-um-algoritmo">O que é um algoritmo</a>
                </li>
                <li>
                    <a href="#412-visão-geral-de-todas-estruturas">Visão geral de todas estruturas</a>
                </li>
                <li>
                    <a href="#413-o-que-é-um-bloco-de-código">O que é um bloco de código</a>
                </li>
                <li>
                    <a href="#414-comentário-de-um-código">Comentário de um código</a>
                </li>
            </ol>
            <li>
                <a href="#42-variáveis-letvar-e-const">Variáveis (let,var e const)</a>
            </li>
            <li>
                <a href="#43-tipos-de-dados-primitivos-string-boolean-number">Tipos de dados primitivos (string, boolean, number)</a>
            </li>
            <li>
                <a href="#44-estrutura-de-dados-array-e-objetos">Estrutura de dados (array e objetos)</a>
            </li>
            <li>
                <a href="#45-operadores">Operadores</a>
            </li>
            <ol>
                <li>
                    <a href="#451-atribuição">Atribuição</a>
                </li>
                <li>
                    <a href="#452-destructing">Destructing</a>
                </li>
                <li>
                    <a href="#453-aritméticos">Aritméticos</a>
                </li>
                <li>
                    <a href="#454-relacionais">Relacionais</a>
                </li>
                <li>
                    <a href="#455-lógicos">Lógicos</a>
                </li>
                <li>
                    <a href="#456-unário-e-ternário">Unário e Ternário</a>
                </li>
            </ol>
            <li>
                <a href="#46-estruturas-de-controle">Estruturas de controle</a>
            </li>
            <ol>
                <li>
                    <a href="#461-if">if</a>
                </li>
                <li>
                    <a href="#462-if-else">if else</a>
                </li>
                <li>
                    <a href="#463-switch">switch</a>
                </li>
                <li>
                    <a href="#464-while">while</a>
                </li>
                <li>
                    <a href="#465-do-while">do while</a>
                </li>
                <li>
                    <a href="#466-for">for</a>
                </li>
                <li>
                    <a href="#467-for-in">for in</a>
                </li>
            </ol>
            <li>
                <a href="#47-clonando-objetos-shallow-copy-x-deep-copy">Clonando Objetos, Shallow Copy x Deep Copy</a>
            </li>
            <ol>
                <li>
                    <a href="#471-shallow-copy">Shallow Copy</a>
                </li>
                <li>
                    <a href="#472-deep-copy">Deep Copy</a>
                </li>
            </ol>
            <li>
                <a href="#48-funções">Funções</a>
            </li>
            <ol>
                <li>
                    <a href="#481-função-arrow">Função arrow</a>
                </li>
                <li>
                    <a href="#482-funções-do-array">Funções do array</a>
                </li>
                <ol>
                    <li>
                        <a href="#4821-foreach">Foreach</a>
                    </li>
                    <li>
                        <a href="#4822-map">Map</a>
                    </li>
                    <li>
                        <a href="#4823-filter">Filter</a>
                    </li>
                    <li>
                        <a href="#4824-reduce">Reduce</a>
                    </li>
                </ol>
            </ol>
            <li>
                <a href="#49-promises-async-e-await">Promises, Async e Await</a>
            </li>
        </ol>
        <li>
            <a href="#5-type-script">Type Script</a>
        </li>
        <ol>
            <li>
                <a href="#51-tipos-de-dados-básico">Tipos de dados básico</a>
            </li>
            <ol>
                <li>
                    <a href="#511-number">Number</a>
                </li>
                <li>
                    <a href="#512-string">String</a>
                </li>
                <li>
                    <a href="#513-array">Array</a>
                </li>
                <li>
                    <a href="#514-tuple">Tuple</a>
                </li>
                <li>
                    <a href="#515-enum">Enum</a>
                </li>
                <li>
                    <a href="#516-boolean">Boolean</a>
                </li>
                <li>
                    <a href="#517-null-e-undefined">Null e Undefined</a>
                </li>
                <li>
                    <a href="#518-any">Any</a>
                </li>
                <li>
                    <a href="#519-void">Void</a>
                </li>
                <li>
                    <a href="#5110-object">Object</a>
                </li>
            </ol>
            <li>
                <a href="#52-inferência-de-tipos">Inferência de Tipos</a>
            </li>
            <li>
                <a href="#53-union-types">Union Types</a>
            </li>
            <li>
                <a href="#54-funções-em-typescript">Funções em TypeScript</a>
            </li>
            <ol>
                <li>
                    <a href="#541-declaração-de-funções">Declaração de Funções</a>
                </li>
                <li>
                    <a href="#542-parâmetros-e-tipos">Parâmetros e Tipos</a>
                </li>
                <li>
                    <a href="#543-valor-de-retorno">Valor de Retorno</a>
                </li>
            </ol>
            <li>
                <a href="#55-interfaces">Interfaces</a>
            </li>
            <ol>
                <li>
                    <a href="#551-criando-e-usando-interfaces">Criando e usando interfaces</a>
                </li>
                <li>
                    <a href="#552-extensão-de-tipos-com-interfaces">Extensão de tipos com interfaces</a>
                </li>
            </ol>
            <li>
                <a href="#56-type-aliases">Type Aliases</a>
            </li>
            <ol>
                <li>
                    <a href="#561-criando-e-usando-type-aliases">Criando e usando type aliases</a>
                </li>
                <li>
                    <a href="#562-extensão-de-tipos-com-type-aliases">Extensão de tipos com type aliases</a>
                </li>
            </ol>
            <li>
                <a href="#57-genéricos">Genéricos</a>
            </li>
            <ol>
                <li>
                    <a href="#571-introdução-aos-genéricos">Introdução aos genéricos</a>
                </li>
                <li>
                    <a href="#572-usando-genéricos-em-funções-e-classes">Usando genéricos em funções e classes</a>
                </li>
            </ol>
            <li>
                <a href="#58-tratamento-de-erros">Tratamento de erros</a>
            </li>
            <ol>
                <li>
                    <a href="#581-lidando-com-exceções-em-typescript">Lidando com exceções em TypeScript</a>
                </li>
                <li>
                    <a href="#582-tipos-de-erro">Tipos de Erro</a>
                </li>
            </ol>
        </ol>
        <li>
            <a href="#6-vídeos-de-conteúdo-complementar"> Vídeos de conteúdo complementar</a>
        </li>
        <li>
            <a href="#7-referências-bibliográficas"> Referências Bibliográficas</a>
        </li>
 </ol>
</details>

---

## 1. Extensões para VsCode

## 2. Overview Java Script

## 3. Primeiro Hello World

## 4. Lógica de Programação em JS

### 4.1. Princípios de programação

#### 4.1.1. O que é um algoritmo

Algoritmo é diretamente afetado pela linguagem de programação utilizada, mas ele não é ligado apenas a programação, na verdade ele é um sequência de passos que são necessários para executar determinada ação. Como exemplo, cada pessoa tem um algoritmo ao acordar até estar pronto para atividades do dia, tem aqueles que preferem 1° levantar, 2° lavar o rosto, 3° tomar café, 4° escovar os dentes e 5° arrumar a cama, tem outros que preferem escovar os dentes antes do café, e aqueles que nem arrumam a cama pois vão deitar de novo de noite. Mas, são nestas situações que se consegue observar o que é um algoritmo.

Além disso, também cabe ressaltar que um algoritmo pode conter repetições de tarefas, ou seja, no exemplo dado eu posso tomar café duas vezes, mas também, posso tomar café até acabar o sono. Assim, observa-se que pode-se haver repetições que ocorrem por um número determinado de vezes ou aquelas que acontecem até que determinada condição seja satisfeita.

Outra possibilidade em um algoritmo é a tomada de decisão, ou seja, posso decidir se vou executar algum passo ou não. Como no exemplo já citado, se a pessoa acordar sem fome, ela pode optar por não tomar o café, ou, como já dito, se estiver com ânimo, arruma a cama, se não, deixa sem arrumar mesmo.

Algo que deve-se atentar em um algoritmo é a ordem de execução dos passos, pois estes podem alterar o resultado. Imagine, no exemplo citado, se a pessoa lava o rosto antes de se levantar, isso resultaria no famoso balde de água na cara para acordar. E assim como essa situação não é muito desejada, os problemas gerados por passos em ordem errada trazem o conhecido “bug” para a programação.

Por fim, um último ponto importante a ressaltar de um algoritmo é que ele pode ter entradas, processamento (realizar o passo a passo) e liberar uma saída. Então, seguindo o exemplo, poderia-se considerar que a entrada é a pessoa ao acordar e dependendo de como for o processamento, ou seja, os passos, vai ter como saída uma pessoa feliz ou desanimada para o seu dia.

Como curiosidade deixo que os algoritmos podem ser representados de várias formas, sendo algumas delas:

- Fluxograma
- Linguagem Natural (Inglês, Português, Alemão, etc)
- Linguagem Artificial (Java Script, Java, C++, Python, etc)
- Pseudo-Linguagem

#### 4.1.2. Visão geral de todas estruturas

Primeiramente é importante definir os dados, ou seja, são todas as informações que são utilizadas por um algoritmo, sejam estas, uma palavra, um número, um valor booleano, um objeto, etc. Desta forma, tem-se as Estruturas de Dados que existem para organizar e administrar os dados que são utilizados.

Desta forma algumas das estruturas de dados clássicas são:

- Lista (um conjunto de elementos que pode ter ordem ou não)
- Fila (FIFO - First in First out - primeiro a entrar é o primeiro a sair)
- Pilha (LIFO - Last in First out - último a entrar é o primeiro a sair)
- Árvore (como o sistemas de arquivos do computador)
- Tabelas (organizar os dados em linhas e colunas)

Também tem-se estruturas básica de dados para as linguagens de programação:

- int (números inteiros)
- real (números reais, ou seja, número com casas decimais)
- char (letras e símbolos)
- string (conjunto de letras, existe em apenas algumas linguagens)
- bool (valores lógicos, ou seja, verdadeiro ou falso)

Mas algumas linguagens, assim como o JS, não separam o int do real, tudo é number. E assim, já podemos observar que essas estruturas básicas são utilizadas para criar estruturas mais complexas dentro das linguagens, como exemplo na construção de objetos.

Outro ponto é que nas linguagens de programação os dados podem ser armazenados em variáveis ou constantes, que, como o nome indica, guardarão, respectivamente, valores que variam com o tempo e valores que são fixos.

Por fim, com os dados armazenados em variáveis e organizados pelas estruturas pode-se realizar diversas operações com eles, como as de atribuição, aritméticas, relacionais e lógicas.

#### 4.1.3. O que é um bloco de código

Um bloco de código é definido por um par de chaves `{}`, que têm a funcionalidade de separar algumas instruções específicas que compõem um grupo de um funcionalidade. Isso será muito importante para quando chegar na parte de funções, mas, por enquanto, tem-se um exemplo de dois blocos de código.

```javascript
{
  console.log("Bloco de código 1");
}

{
  console.log("Bloco de código 2");
}
```

Vale ressaltar que pode-se encontrar um bloco dentro de outro, o que denominamos como blocos aninhados. Mas não há como ter uma intersecção entre blocos. Sendo assim, segue um exemplo de um bloco aninhado.

```javascript
{
  console.log("Bloco externo");
  {
    console.log("Bloco interno");
  }
}
```

#### 4.1.4. Comentário de um código

Aqui no Ex Machina prezamos pelo clean code, ou seja, um código que é de fácil entendimento só de olhar. Para isso, você deve tentar colocar os nomes de variáveis e de funções sempre da maneira mais clara e correlacionada possível.

Contudo, comentários podem ser feitos para fornecer uma melhor explicação da funcionalidade de um determinado bloco de código. Essa prática de comentários é altamente recomendada na fase de aprendizagem, pois você pode aproveitar deste recurso para anotar algo novo ou até um macete para guardar como utilizar o conteúdo aprendido.

Portanto, para fazer um comentário em JS basta colocar duas barras `//` para comentar somente uma linha e barra-asterisco e asterisco-barra `/* */` para comentar várias linhas. Veja como fazer no exemplo abaixo:

```javascript
//esse é um comentário de uma linha

/*
  esse é um
  comentário
  de várias linhas
*/
```

OBS: existe um atalho para comentar uma linha ou várias linhas, geralmente basta selecionar as linhas desejadas depois utilizar a teclas CTRL + / (ou CTRL + : ) para comentar as linhas desejadas.

### 4.2. Variáveis (let,var e const)

### 4.3. Tipos de dados primitivos (string, boolean, number)

### 4.4. Estrutura de dados (array e objetos)

Como já explicitado anteriormente, as estruturas de dados servem para organizar as informações. Sendo assim, duas maneiras comumente utilizadas são o array e os objetos. O primeiro, também chamado de vetor, é uma coleção de dados que podem ser de qualquer tipo, até mesmo objeto ou outros vetores (matriz), e para sua definição utiliza-se os colchetes [], como nos exemplos abaixo.

```javascript
const numeros = [1, 2, 3, 4, 5];
const letras = ["a", "b", "c", "d", "e"];
const palavras = ["Olá", "mundo", "do", "JavaScript"];
```

Como pode-se observar, são vários elementos dentro de um vetor, sendo assim, para acessá-los basta colocar o nome do vetor e dentro dos colchetes a posição do elemento que você deseja acessar. É muito importante lembrar que a contagem começa em 0, então se você deseja recuperar o primeiro elemento do array números deve digitar: `numeros[0]`. Com esse comando você receberá como resposta o número 1 presente no vetor.

Esta notação do nome do vetor e colchetes com a posição também pode ser utilizada para trocar o valor em uma posição, como exemplo: `letras[2] = 'c'`. Além disso existe a função `push` para adicionar valores e a `pop` para retirar valores do fim do array. Também, cabe ressaltar que existem várias outras funções específicas para trabalhar com os arrays, elas serão especificadas na seção [4.8.2 Funções do Array](#482-funções-do-array).

Já quando se trata de objetos diferencia-se um pouco da ideia dos arrays de juntar valores em posições específicas. Os objetos na verdade são uma maneira de você juntar informações, o que permite criar uma estrutura personalizada para o caso em que está trabalhando. Como exemplo um produto do site Extoque tem a seguinte estrutura de objeto:

```javascript
const produto = {
  nome: "Arroz",
  categoria: "Alimento",
  descrição: "Arroz branco",
  validade: "2022-12-31",
  baixoEstoque: 10.0,
  preco: 25.0,
  quantidade: 15.0,
  unidade: "pacotes",
};
```

Assim, é possível notar que você pode usar a criatividade com gosto e fazer um objeto que atenda todas as necessidades, como ter dentro dele um array ou até mesmo outro objeto.

Para acessar um atributo do objeto, ou seja, uma de suas características, basta colocar nome do objeto, ponto e nome do atributo como: `produto.preco`. Outra opção é usar uma notação semelhante a do array: `produto["preco"]`. Então, essas duas sintaxe, assim como no array, podem ser usadas para inserir ou modificar valores.

Por fim, um ponto importante a se destacar sobre objetos é que eles não são a mesma coisa que um JSON. Pois, o JSON foi baseado no objeto do JS, mas ele é um formato textual que é usado para trocar dados entre sistemas distribuídos (sistemas na internet).

### 4.5. Operadores

#### 4.5.1. Atribuição

#### 4.5.2. Destructing

#### 4.5.3. Aritméticos

#### 4.5.4. Relacionais

#### 4.5.5. Lógicos

#### 4.5.6. Unário e Ternário

### 4.6. Estruturas de controle

Como já familiarizado anteriormente, estruturas agem no sentido de organizar e as estruturas de controle vão agir justamente na organização da execução do código, ou seja, qual passo vai seguir, assim como foi explicado na introdução a um algoritmo. Sendo assim, a seguir serão explicadas as principais estruturas utilizadas. Vale ressaltar que, assim como os blocos de códigos, elas podem ser aninhadas entre si ou com outras, visando atingir os objetivos desejáveis.

#### 4.6.1. if

Estrutura para fazer o “se”, ou seja, ela verifica se um condição é verdadeira para executar certa parte definida do código. Desta forma, utiliza fortemente os operadores relacionais e lógicos. Um exemplo é:

```javascript
if (nota >= 7) {
  console.log("Aprovado emm, só sucesso! Passou com " + nota);
}
```

#### 4.6.2. if else

Estrutura que complementa o if. Ou seja, se algo não for verdadeiro ela executará a parte do “se não”. Sendo assim, complementando o exemplo acima:

```javascript
if (nota >= 7) {
  console.log("Aprovado emm, só sucesso! Passou com " + nota);
} else {
  console.log("Não foi dessa vez. Sua nota foi " + nota);
}
```

Mas vale ressaltar que pode-se ter uma sequência de ifs e elses, além de aninhar essas estruturas.

#### 4.6.3. switch

Essa estrutura, assim como um if, testa se determinada condição é verdadeira para executar um pedaço de código. Contudo, ela tem uma entrada de qualquer tipo e casos. Para cada caso, ela verifica se a entrada é equivalente à opção que o caso fornece.

Se um caso for verdade ele será executado, senão vai procurar até achar o primeiro que se encaixe. Nota-se, então, que se tiver dois casos iguais apenas o superior será executado.

Para ficar mais fácil a seguir será apresentado um switch para avaliar a quantidade de estrelas fornecida por um usuário:

```javascript
switch (qntEstrelas) {
  case 1:
    console.log("Péssimo");
    break;
  case 2:
    console.log("Ruim");
    break;
  case 3:
    console.log("Regular");
    break;
  case 4:
    console.log("Bom");
    break;
  case 5:
    console.log("Excelente");
    break;
  default:
    console.log("Quantidade de estrelas inválida");
    break;
}
```

Como é possível notar o `:` indica o começo do caso e o `break` indica o final. Mas vale ressaltar que o break não é obrigatório e sua omissão pode ser utilizada para quando dois cases diferentes possuem o mesmo retorno, basta colocá-los em seguida e colocar no break apenas no case inferior.

Por fim, no exemplo acima pode-se ver que quando não encontra nenhuma opção para `qntEstrelas` temos o `default` que funciona justamente para suprir quando não há um caso válido. Também, vale pontuar que ele não é obrigatório, mas é uma boa prática de programação.

#### 4.6.4. while

Essa estrutura encaixa-se na categoria de repetição, isso porque, assim como o seu nome indica, enquanto uma afirmação for verdadeira ela continuará a executar as instruções de código que se encontram em seu bloco.

Desta forma, ela também utiliza as expressões lógicas seguindo a mesma forma utilizada no if. Em seguida tem-se um exemplo:

```javascript
while (sono === true) {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
}
```

Vale ressaltar que a instrução `Math.random() >= 0.5` apenas foi utilizada para sortear aleatoriamente um booleano. O que indica uma importante característica da estrutura while, nela geralmente não se sabe quantas vezes vai repetir, isso depende da expressão que está sendo testada.

Nesse caso, também poderia ter sido utilizada uma sintaxe mais compacta, como no exemplo abaixo.

```javascript
while (sono) {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
}
```

Isso acontece porque a variável sono já possui um valor booleano, então a operação `sono === true` sempre terá o valor igual a própria variável.

Obs: essa maneira mais compacta também pode ser utilizada para outros tipos de variáveis (Number, String, etc), que passarão por uma conversão de tipos para Boolean, o que nem sempre será algo previsível porque JavaScript é estranho (e nem é meme).

#### 4.6.5. do while

Essa estrutura também é uma dentre as de repetição, mas a sua diferença para o while explicado anteriormente é a verificação da expressão. Ou seja, no while primeiro verifica se a expressão é verdadeira para depois executar as instruções presente no bloco, já o do while é o oposto primeiro executa as instruções e depois verifica a expressão. Esse modelo inverso, garante que pelo menos uma vez ocorrerá a execução das instruções presentes neste bloco. A seguir tem-se o exemplo anterior modificado para o do while:

```javascript
do {
  console.log("A mimir!");
  sono = Math.random() >= 0.5;
} while (sono);
```

Então, aqui sabemos que pelo menos uma vez será impresso “A mimir!” o que não acontecia no exemplo anterior.

#### 4.6.6. for

Essa estrutura também é uma repetição, mas diferente do while o seu número de repetições é conhecido antes dela iniciar. Ou seja, deve ser utilizada em contexto que o número de repetições é definido.

Esta estrutura possui uma sintaxe semelhante ao while, mas dentro dos parênteses ela apresenta 3 partes principais: sendo a 1° a definição da variável que servirá como um contador para as repetições, a 2° a expressão para verificar se a contagem já chegou ao ponto desejado e, por fim, a 3° a forma como a contagem será realizada.

A seguir será apresentado um exemplo de um for que realiza uma contagem de 1 a 10:

```javascript
for (let i = 1; i <= 10; i++) {
  console.log("i:" + i);
}
```

Como podemos observar a variável i é setada para 1 que indica de onde a contagem irá se iniciar e a expressão `i <= 10` verifica se já chegou ao limite que é 10. Já o `i++` é uma expressão para indicar que será acrescida uma unidade em i a cada repetição, utilizando o operador unário. Caso desejasse, por exemplo, contar de 2 em 2 elementos poderia utilizar `i+=2`.

#### 4.6.7. for in

Essa estrutura assemelha-se ao for, ou seja, também é utilizada para fazer repetição. Contudo, ela tem como objetivo específico percorrer uma estrutura de dados, como um array ou um objeto.

A seguir um exemplo desta função para cada estrutura de dados citada:

```javascript
const notas = [6.7, 7.4, 9.8, 8.1, 7.7];

for (let i in notas) {
  console.log(i, notas[i]);
}

const pessoa = {
  nome: "Ana",
  sobrenome: "Silva",
  idade: 29,
  peso: 64,
};

for (let atributo in pessoa) {
  console.log(`${atributo} = ${pessoa[atributo]}`);
}
```

### 4.7. Clonando Objetos, Shallow Copy x Deep Copy

#### 4.7.1. Shallow Copy

#### 4.7.2. Deep Copy

### 4.8. Funções

Funções podem ser definidas simplesmente como um conjunto de instruções agrupadas em um bloco de código. Geralmente elas possuem um objetivo específico e podem ou não ter um retorno e parâmetros.

Outro ponto importante sobre funções é que no JS elas podem ser criadas de forma literal, armazenadas em um variável ou em um atributo de um objeto. Como nos exemplos a seguir:

```javascript
//criar de forma literal - sempre retorna undefined por default
function fun1() {}

//armazenar em uma variável
const fun2 = function () {};

//armazenar em um atributo de objeto
const obj = {};
obj.falar = function () {
  return "Opa";
};
console.log(obj.falar());
```

Para executar (chamar ou invocar) as instruções internas de uma função, basta adicionar o nome da função e um par de parênteses, como foi possível observar no último exemplo: `obj.falar()`. Acredito que nesse momento você deve ter percebido que vem utilizando uma função desde o início desta capacitação e agora que se deu conta. E essa função que já é familiar para você, está armazenado em um atributo do console, ou seja, é a função log que faz todas as informações serem mostradas no terminal.

Outro ponto importante para as funções são seus parâmetros, ou seja, os valores que são passados para que seja possível realizar alguma operação interna, como exemplo clássico temos um função soma que recebe dois parâmetros e retorna o valor da soma entre eles:

```javascript
const soma = function (x, y) {
  return x + y;
};
```

Por último, cabe ressaltar que foi possível observar pelos exemplos que algumas funções possuíam a palavra `return` e outras não. Isso significa que uma função pode ou não ter um retorno, então no exemplo da função soma apresentada, ela retorna o valor da soma para onde ele é necessário (onde a função foi chamada), mas dependendo da aplicação ele poderia ser simplesmente imprimido por um `console.log()` e a função não retornaria nada.

#### 4.8.1. Função arrow

Aqui no Ex Machina temos nosso jeito preferido de usar as funções do JS e ela é o arrow function. A seguir tem-se um exemplo de como uma função é transformada para uma funções arrow:

```javascript
let dobroA = function (a) {
  return 2 * a;
};

//função arrow eh sempre anônima
//deve sempre ser associada a uma variável
const dobroB = (a) => {
  return 2 * a;
};

const dobroC = (a) => 2 * a; //return está implícito
```

Como pode-se perceber esse tipo de função tem menos elementos que a função tradicional, o que deixa mais agradável de programar e, também, como o costume mais fácil de entender.

Outro ponto importante para utilização de funções arrow é que funções podem receber funções como um parâmetro e devido ao formato reduzido fornecido pelas arrows elas se encaixam muito bem nesse papel, isso será demonstrado na próxima seção nas Funções do array.

#### 4.8.2. Funções do array

##### 4.8.2.1. Foreach

##### 4.8.2.2. Map

##### 4.8.2.3. Filter

##### 4.8.2.4. Reduce

### 4.9. Promises, Async e Await

Até o momento vimos códigos síncronos, ou seja, códigos que a linha de baixo só é executada depois que a linha de cima termina sua execução. Nesta seção trabalharemos com códigos assíncronos, ou seja, agora uma função é chamada e o código continua sendo executado, mas depois que a resposta chega a função que a chamou a processa. Isso acontece com muita frequência quando está trabalhando com requisições para um banco de dados você pede um dado e ele te retorna um promessa que vai processar a sua requisição e quando terminar ele te retorna a sua resposta.

Desta forma, as Promises vieram justamente para trabalhar com essas promessas de retorno para requisições. A seguir tem-se um exemplo simples de uma promise:

```javascript
function falarDepoisDe(segundos, frase) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(frase, "abc");
    }, segundos * 1000);
  });
}

falarDepoisDe(3, "Que legal!")
  .then((frase, abc) => {
    console.log(abc);
    //undefined pq só aceita um parametro msm mandando 2
    return frase.concat("?!?");
  })
  .then((outraFrase) => console.log(outraFrase)) //chama a vontade
  .catch((e) => console.log(e));
//para tratar erros quando usa o reject, mas chama uma vez só
```

Este exemplo utiliza a função `setTimeout` para simular a demora por uma resposta, visto que a função só retorna algo depois de passar o tempo definido. Sendo assim, a função falarDepoisDe retorna uma Promise, que tem duas funções internas para tratar o resultado, se o valor requisitado não tiver problemas a função `resolve` será executada, se ocorrer algum erro durante a espera a função `reject` que será executada.

Já sobre a chamada da função percebe-se que segue o mesmo padrão das funções síncronas, a diferença consiste no then que passa justamente a função resolve que a promise irá executar. Sobre o `then` pode-se notar que ele pode ser chamado quantas vezes necessárias, mas que só aceita um parâmetro por vez. Já a outra diferença é o `catch`, o qual se relaciona a função reject da promise para tratar os erros.

Contudo, a utilização de promisses com then e catch, além de ser muito verbosa é complexa de se trabalhar. Por isso, o mais comum e o que utilizamos no Ex é a dupla famosa Async e Await. A seguir tem-se um exemplo de como eles trabalham como promises:

```javascript
const esperarPor = (tempo = 2000) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Executando promise...");
      resolve();
    }, tempo);
  });
};
//por trás do async e do await sempre tem que ter um promise
const executar = async () => {
  await esperarPor(1500);
  console.log("Async/Await 1...");

  await esperarPor(1500);
  console.log("Async/Await 2...");

  await esperarPor(1500);
  console.log("Async/Await 3...");
};

//se retornasse um valor e quisesse usá-lo tem que usar o then pq ela retorna uma promise
executar();
```

Como pode-se perceber, o exemplo é bem semelhante ao anterior, mas dessa vez o Async e Await servem para tratar uma promise como se ela fosse um função síncrona, ou seja, primeiro espera-se o retorno da função para depois continuar a executar o código.

Desta forma, como é possível notar, para usar o async e o await, basta criar uma função que seja assíncrona colocando o async antes do nome da função, como demonstrado no exemplo. E, para esperar a resposta, basta colocar o await na frente da chamada de uma função que retorna uma promise.

Por fim, não necessita o then já que o await faz o papel dele e o catch continua sendo opcional como era anteriormente, a diferença é que ele é feito por meio do tratamento de erros, como será explicado na seção [5.8. Tratamento de Erros](#58-tratamento-de-erros).

## 5. Type Script

### 5.1. Tipos de dados básico

#### 5.1.1. Number

#### 5.1.2. String

#### 5.1.3. Array

#### 5.1.4. Tuple

#### 5.1.5. Enum

#### 5.1.6. Boolean

#### 5.1.7. Null e Undefined

#### 5.1.8. Any

#### 5.1.9. Void

#### 5.1.10. Object

### 5.2. Inferência de Tipos

### 5.3. Union Types

### 5.4. Funções em TypeScript

#### 5.4.1. Declaração de Funções

#### 5.4.2. Parâmetros e Tipos

#### 5.4.3. Valor de Retorno

### 5.5. Interfaces

### 5.5.1. Criando e usando interfaces

#### 5.5.2. Extensão de tipos com interfaces

### 5.6. Type Aliases

#### 5.6.1. Criando e usando type aliases

#### 5.6.2. Extensão de tipos com type aliases

### 5.7. Genéricos

### 5.7.1. Introdução aos genéricos

#### 5.7.2. Usando genéricos em funções e classes

### 5.8. Tratamento de erros

#### 5.8.1. Lidando com exceções em TypeScript

#### 5.8.2. Tipos de Erro

## 6. Vídeos de conteúdo complementar

## 7. Referências Bibliográficas
